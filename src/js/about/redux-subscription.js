/**
 * Для того чтобы сообщить "внешнему миру" о том что состояние изменилось мы подпишемся на обновления, передав функцию обратного вызова (+)
 * Для реализации этого механизма ипсольуем паттерн "Наблюдатель"
 * ...
 * (+) Callback-функция (функция обратного вызова) — передача исполняемого кода в качестве одного из параметров другого кода. Обратный вызов позволяет в функции исполнять код, который задаётся в арг ументах при её вызове. Этот код может быть определён в других контекстах программного кода и быть недоступным для прямого вызова из этой функции. Некоторые алгоритмические задачи в качестве своих входных данных имеют не только числа или объекты, но и действия (алгоритмы), которые естественным образом задаются как обратные вызовы.
 */

function updateState(state, action) {
  if (action.type === 'INCREMENT') {
    return state + action.amount;
  } else if (action.type === 'DECREMENT') {
    return state - action.amount;
  } else {
    return state;
  }
}

class Store {
  constructor(updateState, state) {
    this._updateState = updateState;
    this._state = state;
    // Свойство, в котором будет храниться список функций
    this._callbacks = [];
  }

  get state() {
    return this._state;
  }

  /**
   * После изменения состояния перебираем массив с функциями и вызвать каждую функцию.
   * В функцию callback() мы не передаем никаких аргументов, просто уведомляем подписчика об изменении состояния
   */
  update(action) {
    this._state = this._updateState(this._state, action);
    this._callbacks.forEach(callback => callback());
  }

  /**
   * Метод, с помощью которого можно будет подписаться на обновление состояния.
   * Метод принимает функцию обратного вызова (параметр callback).
   * В массив _callbacks добавляем переданную нам функцию.
   */
  subscribe(callback) {
    this._callbacks.push(callback);
    /**
     * Механизм отписки необходим для очистки мусора (и занимаемой памяти) в хранилище когда какой-то объект больше не нужен.
     * Можно было бы написать функцию обратного вызова, которая искала бы функцию в массиве и удаляла бы ее из этого массива.
     * Так несколько проще. Метод subscribe() возвращает функцию, которая удалит в свою очередь функцию обратного вызова.
     * Для этого в теле функции мы проверяем не является ли очередная функция из массива функцией, передаваемой в метод subscribe().
     */
    return () =>
      (this._callbacks = this._callbacks.filter(cb => cb !== callback));
  }
}

const store = new Store(updateState, 0);

const incrementAction = { type: 'INCREMENT', amount: 5 };
const decrementAction = { type: 'DECREMENT', amount: 3 };

/**
 * Вместо того чтобы проверять каждый раз, изменилось ли состояние (.log), подписываемся на обновления с помощью метода subscribe()
 * Метод subscribe() не принимает никаких параметров. С помощью свойства .state посмотрим на состояние.
 * От метода subscribe() будем получать функцию, сохраняем ее в постоянной.
 * После первого изменения состояния вызовем функцию unsubscribe();
 */
const unsubscribe = store.subscribe(() =>
  console.log('State changed #1:', store.state)
);
/**
 * Добавляем еще одного подписчика
 */
store.subscribe(() => console.log('State changed #2:', store.state));

store.update(incrementAction); // (1) Второй подписчик уведомлен три раза

unsubscribe(); // Первый подписчик был уведомлен один раз и отписался

store.update(decrementAction); // (2) Второй подписчик уведомлен три раза

store.update({}); // (3) Второй подписчик уведомлен три раза
